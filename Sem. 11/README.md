
**Приоритетна опашка**, трябва най-малко да поддържа следните операции:

 - добавяне с приоритет – добавя елемент на опашката със съответен приоритет.
 - изваждане на елемента с най-висок приоритет
 
 Реализация с **двоична пирамида** **(Binary heap)**.
 
![enter image description here](https://i.ibb.co/yf7TVSY/1200px-Max-Heap-svg.png)

Забележка: В примерите е реализирана макс. двоична пирамида - max binary heap.(Съществува и  min binary heap)

**Задача 1:** Да се реализира строене на двоична пирамида от произволен масив със сложност **О(n)**.
Използвайте функцията **heapify**.

![enter image description here](https://i.ibb.co/K9DsZTg/Untitled-Diagram.png)

**Задача 2:** Да се реализира сортиращия алгоритъм **HeapSort**.

## Домашна работа

Реализирайте приоритетна опашка с троична-минимална пирамида **(Ternary heap)**.
В нашата опашка искаме да изваждаме първо елементите с най-нисък приоритет (най-малките числа).
Троична-минимална пирамида е **пълно троично дърво.**

 - Всеки връх има най-много 3 наследника.
 - Всеки връх е по-малък или равен от наследниците си.
 - Всяко ниво е пълно, с изключение на последното, което е запълнено от ляво надясно.
 
Реализирайте сортиращ алгоритъм **ternaryHeapSort**, който сортира произволен масив, използвайки вече реализираната приоритетна опашка.

![enter image description here](https://i.ibb.co/VCCHF5S/Untitled-Diagram-1.png)
