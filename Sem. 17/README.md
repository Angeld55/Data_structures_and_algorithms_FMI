

### Изпитни задачи
### Задача 1.
Реализирайте кеш "най-отдавна използван", който премахва най-отдавна използвания елемент. Кешът трябва да пази свойки <ключ, стойност>, позволява взимането и премахването на двойка и трябва да бъде инициализиран с максимален капацитет. Когато се запълни, кешът трябва да премахне елементът, който най-отдавна е използван.

Използвайте leastRecentlyUsed.cpp за тестване.

Design and build a "least recently used" cache, which evicts the least
 recently used item. The cache should map from keys to values (allowing you
to insert and retrieve a value associated with a particular key) and be
initialized with a max size. When it is full, it should evict the least
recently used item.
   ```c++
int main(int argc, char *argv[]) 
{
	  int request = 1;
      std::string response = getResponse<int, std::string>(request); //slow
      response = getResponse<int, std::string>(request); //fast
    	
      request = 2;
      response = getResponse<int, std::string>(request); //slow
      response = getResponse<int, std::string>(request); //fast
    	
      request = 1;
      response = getResponse<int, std::string>(request); //fast
    
      request = 3;
      response = getResponse<int, std::string>(request); //slow
      response = getResponse<int, std::string>(request); //fast
      
      request = 1;
      response = getResponse<int, std::string>(request); //fast
      
      request = 2;
      response = getResponse<int, std::string>(request); //slow

      return 0;

}
```

### Задача 2
"**Лявоориентиран път"** в двоично дърво се нарича всеки път от корена на дървото до листо, в който движението винаги се извършва наляво към левия наследник и се допуска най-много едно придвижване надясно.

Пример за такива пътища в следното двоично дърво са:

-   8 =>L 3 =>L 1 (вървим винаги наляво)
    
-   8 =>L 3 =>R 6 =>L 4 (има едно единствено движение надясно)
-   
![enter image description here](https://i.ibb.co/pWLWx9x/Screen-Shot-2021-09-06-at-10-55-55-PM.png)

Да се напише функция, която по подаден указател към корена на двоично дърво от цели числа, намира всички лявоориентирани пътища и извежда на стандартния изход тези от тях, които удовлетворяват подаден предварително предикат

### Задача 3
Нека е дадена следната структура:

struct Node {int data; Node<int> *next;};

Реализирайте функция  inc(Node* list), която приема като параметър указател към първия елемент на свързан списък с **четен брой елементи**, чиито елементи са цели числа в интервала [0..9]. Функцията да  изважда единица от  **десетичното число**, което е представено в първата половина на списъка, и да добавя единица към  **десетичното число**, което е представено във втората половина. Функцията да връща указател към началото на списъка.  

Пример: Списъкът

1->9->0->0->9->9->9->9

се трансформира до списъка:

1->8->9->9->1->0->0->0->0

Обяснение:  
Числото в първата половина е 1900 - 1 = 1899  
Числото във втората половина е 9999 + 1 = 10000

### Задача 4
 От стандартния вход постъпват две естествени числа N ≤ 50 и K ≤ 2500, последвани от K на брой двойки от естествени числа (vi, ui), i = 0,...,K-1. Въведените стойности дефинират **неориентиран**  граф граф G: <V={0,...,N-1}, E={(vi, ui) | i = 0,...,K-1} U {(ui, vi) | i = 0,...,K-1}}. Да се реализира подходящо представяне на графа и за така въведения граф да се намери и изведе на стандартния изход:

1.  Броя на различните му свързани компоненти.
2.  За всяка свързана компонента да се изведе списък с върховете, които принадлежат към нея.
3.  Информацията за свързаните компоненти да се изведе подредена относно броя на елементите им.



### Задача 5
 Да се дефинира шаблон Counter<T>, който реализира “преброител” на елементи от тип T. Преброителят се инициализира с нулева бройка за всички елементи от тип T и позволява да се “добавя” и “премахва” по един брой от даден елемент x на T. Шаблонът да дефинира следните операции:

-   [0.25т.] operator +=: увеличава броя на елемента x;
    
-   [0.25т.] съответен оператор +;
    
-   [0.25т.] operator -=: намалява броя на елемента x;
    
-   [0.25т.] съответен оператор -;
    
-   [0.25т.] count: Връща колко елемента имат брой, различен от 0;
    
-   [0.25т.] оператор за индексиране [x], дава броя на x;
    
-   [0.25т.] operator + за събиране на два брояча (бройките на резултатния брояч са сумите на бройките на изходните броячи).
    

Например:

Counter<int> c; c+=0; c+=0; std::cout << c[0] << “,” << c[1];
