***Задача 1:*** Даден е ориентиран граф и стартов връх v. Да се напише функция, която намира сумата на елементите, които са на четно разстояние от G и сумата на елементите, които са на нечетно разстояние от v.
Входът е във вида : цяло число n - брой на върховете, цяло число m - брой на ребрата , m реда във вида a b, което репрезентира ребро от а към b.

**Вход:** 
```c++
5
7
0 4 
0 3
0 1
1 3
1 2
3 2
4 3
```
**Изход:** 
```c++
2, 8	
```
![Task2 example](https://i.ibb.co/wyCC9BT/digraph-1.png)


***Задача 2:***  Даден е неориентиран граф. Намерете сумата на средно аритметичното на върховете на всички свързани компоненти в графа.
Входът е във вида : цяло число n - брой на върховете, цяло число m - брой на ребрата , m реда във вида a b,  което означава
ребро от а към b.
 
 
**Вход:** 
```c++
9
8
7 8 
4 5
4 6
5 6
2 1
0 3
0 1
2 3
```
**Изход:** 
```c++
 14 //7.5 + 5 + 1.5
```
![Task1 example](https://i.ibb.co/xHBsVCh/g1.png)

***Задача 3:*** Напишете функция, която проверява дали дърво с произволен брой наследници погледнато от ляво е същото като погледнато от дясно.

![Task3 example](https://i.ibb.co/Tb9p8DJ/tree.png)

Погледнат от двете страни е:

```c++
5
3
4
9
```
***Задача 4:***
Дадено е дърво с произволен брой наследници.  "Хубав път" в дървото ще наричаме такъв път, в който стойността на всеки връх се дели на стойността на следващия. Да се дефинира функция, която  приема такова дърво и връща най-дългия "хубав път" започващ от корена.

Пример:

![Task4 example](https://i.ibb.co/PtSLJv9/Untitled-Diagram.png)

Изход:

```c++
32 16 1 1
```
