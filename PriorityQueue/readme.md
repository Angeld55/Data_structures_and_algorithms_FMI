d
**Приоритетна опашка**, трябва най-малко да поддържа следните операции:

 - добавяне с приоритет – добавя елемент на опашката със съответен приоритет.
 - изваждане на елемента с най-висок приоритет.

Ако в приоритетната опашка имаме елементи с еднакъв приоритет, то те трябва да се подчиняват на **FIFO** (first in, first out).
 
 Реализация с **двоична пирамида** **(Binary heap)**.
 
![enter image description here](https://i.ibb.co/yf7TVSY/1200px-Max-Heap-svg.png)


По дефинирация двоичната пирамида **не прави разлика между елементи с еднакъв приоритет**. За това в пирамидата **ще пазим наредени двойки < елемент, момент на добавяне >**, за да може да поддържаме FIFO за повтарящите се елементи.

Забележка: В примерите е реализирана макс. двоична пирамида - max binary heap. (Съществува и  min binary heap)



**Задача 1:** Да се реализира строене на двоична пирамида от произволен масив със сложност **О(n)**.
Използвайте функцията **heapify**.

![enter image description here](https://i.ibb.co/K9DsZTg/Untitled-Diagram.png)

**Задача 2:** Да се реализира сортиращия алгоритъм **HeapSort**.

## Задача за упражнение.

**Задача 1:**
Реализирайте приоритетна опашка с троична-минимална пирамида **(Ternary heap)**.
В нашата опашка искаме да изваждаме първо елементите с най-нисък приоритет (най-малките числа).
Троична-минимална пирамида е **пълно троично дърво.**

 - Всеки връх има най-много 3 наследника.
 - Всеки връх е по-малък или равен от наследниците си.
 - Всяко ниво е пълно, с изключение на последното, което е запълнено от ляво надясно.
 
Реализирайте сортиращ алгоритъм **ternaryHeapSort**, който сортира произволен масив, използвайки вече реализираната приоритетна опашка.

![enter image description here](https://i.ibb.co/VCCHF5S/Untitled-Diagram-1.png)

**Задача 2:**
Реализирайте  **K-ary Heap**. - опашка, която има най-много k наследника.
Сравнете производителността при различни стойности на k. За кое k е най-оптимално ?
